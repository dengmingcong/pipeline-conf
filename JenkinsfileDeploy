#!/bin/bash/groovy

/*
** Deploy files to Jenkins agents.
**
** The default values of global variables are set for "debug", not for "stable".
**  
** For deploying 'stable' (not contain 'debug')
**   - Must choose one git tag when building
**   - All git repositories will be updated
**   - Cannot be triggered via webhook
**
** For deploying 'debug' (contain 'debug')
**   - No need to choose git tag when building, latest code of the preset branch will be fetched
**   - Updating one repository is supported
**   - Can be triggered via webhook
*/

properties([buildDiscarder(logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '3', numToKeepStr: '5')), disableConcurrentBuilds(), gitLabConnection('')])

ENV_MAP = [
	ci: [label: "fullTest"],
	testonline: [label: "Predeploy-smokeTest"], 
	predeploy: [label: "Predeploy-smokeTest"]
]

// define global variables for later usage
// treat as tag if true, branch if false
BUSINESS_REPO_NAME = "cloud-api-test"
BUSINESS_REPO_URL = "git@fangcun.vesync.com:testTeam/${BUSINESS_REPO_NAME}.git"
BUSINESS_REPO_BRANCH = "master"  // using tag (instead of branch) is acceptable
PIPELINE_CONF_NAME = "pipeline-conf"
PIPELINE_CONF_URL = "git@fangcun.vesync.com:testTeam/${PIPELINE_CONF_NAME}.git"
PIPELINE_CONF_BRANCH = "dev"
NACOS_JMETER_NAME = "nacos-jmeter"
NACOS_JMETER_URL = "git@fangcun.vesync.com:testTeam/${NACOS_JMETER_NAME}.git"
NACOS_JMETER_BRANCH = "master"

// Determine what to deploy, one of ["all", "cloud-api-test.git", "pipeline-conf.git", "nacos-jmeter.git", "jmeter files", "nacos snapshot"]
UPDATE = params.update

QA_HOME = "/data/qa"
DEPLOY_TO = "${QA_HOME}/deploy/debug"
JMETER_HOME = "${DEPLOY_TO}/jmeter40"
STAGE = ""
AGENT_LABEL = ""
NODE_LIST = []
DEBUG = true
TRACK_AS_TAG = false

// only for deploying "stable"
UPDATE_ON_SAME_VERSION = params["update on same version"]
NEED_UPDATE = true
LOCAL_VERSION_YML = "local-version.yml"


/*
** 1. determine test stage based on Jenkins job name.
** 2. if job name does not contain "debug", then
**   - set DEBUG to false
**   - set DEPLOY_TO to "${QA_HOME}/deploy/stable"
**   - set JMETER_HOME to "/usr/local/jmeter40"
**   - set BUSINESS_REPO_BRANCH to "refs/tags/${params.tagName}"
**   - set UPDATE to "all"
*/
def parseJobName() {
    def jobNameLowerCase = env.JOB_NAME.toLowerCase()

    if (jobNameLowerCase.endsWith("ci")) {
    	STAGE = "ci"
    } else if (jobNameLowerCase.endsWith("testonline")) {
    	STAGE = "testonline"
    } else if (jobNameLowerCase.endsWith("predeploy")) {
    	STAGE = "predeploy"
    } else {
    	error "Your job name ${env.JOB_NAME} is supposed to end with either one of words 'ci', 'testonline', or 'predeploy' (case insensitive)."
    }
	
	if (!jobNameLowerCase.contains("debug")) {
		DEBUG = false
		DEPLOY_TO = "${QA_HOME}/deploy/stable"
		echo "Word 'debug' not found in job name, deploy all files to directory ${DEPLOY_TO}."
		JMETER_HOME = "/usr/local/jmeter40"
		BUSINESS_REPO_BRANCH = "${params.tagName}"
		UPDATE = "all"
	} else {
		echo "Word 'debug' found in job name, deploy all files to directory ${DEPLOY_TO}."
	}
}

/*
** set UPDATE based on "${env.gitlabSourceRepoName}"
** 
** Note: Only push to specific branch can trigger building.
*/
def handleWebhook() {
	def srcRepoName = env.gitlabSourceRepoName
	
	if (srcRepoName) {
		if (DEBUG) {
			echo "Triggered via ${env.gitlabSourceRepoHomepage}"
			
			if (srcRepoName == "${BUSINESS_REPO_NAME}") {
				UPDATE = "cloud-api-test.git"
			} else if (srcRepoName == "${PIPELINE_CONF_NAME}") {
				UPDATE = "group-pipeline"
			} else if (srcRepoName == "${NACOS_JMETER_NAME}") {
				UPDATE = "nacos-jmeter.git"
			}
			echo "Change from branch ${env.gitlabBranch} was pushed, get updates from branch ${env.gitlabBranch}"
		} else {
			error "Only job whose name contains with 'debug' supports webhook now."
		}
	} else {
		echo "Triggered via manual clicking"
	}
	echo "UPDATE is set to: ${UPDATE}"
}

/*
** Pull from remote Git repository to the specified agent.
** The remote repository will be pulled to a directory named with repository.
*/
def pull(String repoName, String repoUrl, branch) {
    echo "Begin to sync repository ${repoUrl}"
    def localRepoDir = "${DEPLOY_TO}/${repoName}"
	def targetVersion = ""
	
	if (TRACK_AS_TAG) {
		targetVersion = "refs/tags/${branch}"
	} else {
		targetVersion = "refs/heads/${branch}"
	}
	
	dstDir = localRepoDir
	sh "[[ -d ${dstDir} ]] || mkdir -p ${dstDir}"
	echo "Pulling repository ${repoName} to directory ${dstDir}"
	checkout([$class: 'GitSCM', branches: [[name: "${targetVersion}"]], doGenerateSubmoduleConfigurations: false, extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: "${dstDir}"], [$class: 'CloneOption', noTags: true, reference: '', shallow: true]], submoduleCfg: [], userRemoteConfigs: [[url: "${repoUrl}"]]])
}

def updateBusinessRepo() {  
	echo "UPDATE ${BUSINESS_REPO_NAME}.git"
	pull(BUSINESS_REPO_NAME, BUSINESS_REPO_URL, BUSINESS_REPO_BRANCH)
}

def updatePipelineConf() { 
	echo "UPDATE ${PIPELINE_CONF_NAME}.git"
	pull(PIPELINE_CONF_NAME, PIPELINE_CONF_URL, PIPELINE_CONF_BRANCH) 
}

def updateNacosJmeterRepo() {
	echo "UPDATE ${NACOS_JMETER_NAME}.git"
	pull(NACOS_JMETER_NAME, NACOS_JMETER_URL, NACOS_JMETER_BRANCH) 
}
def updateJmeterDependencies() {
	echo "UPDATE groovy, jar, xsl (copy from ${PIPELINE_CONF_NAME})"
	sh "cp ${DEPLOY_TO}/${PIPELINE_CONF_NAME}/bin/*.groovy ${JMETER_HOME}/bin"
	sh "cp ${DEPLOY_TO}/${PIPELINE_CONF_NAME}/lib/*.jar ${JMETER_HOME}/lib"
	sh "cp ${DEPLOY_TO}/${PIPELINE_CONF_NAME}/resources/*.xsl ${JMETER_HOME}/extras"
}

def updateNacosSnapshot() {
	echo "UPDATE Nacos snapshot"
	sh "cd ${DEPLOY_TO}/${NACOS_JMETER_NAME}/bin; [[ -d ../snapshot ]] || mkdir ../snapshot; python3 make_snapshot.py ${STAGE} ../snapshot"
}

/*
** set PIPELINE_CONF_BRANCH, NACOS_JMETER_BRANCH based on file "requirementsYml" when deploy "stable"
*/
def setDependentRepoTag(requirementsYml) {
	if (!DEBUG) {
		def requirements = readYaml file: "${requirementsYml}"
		
		PIPELINE_CONF_BRANCH = requirements[PIPELINE_CONF_NAME]
		NACOS_JMETER_BRANCH = requirements[NACOS_JMETER_NAME]
	}
}

/*
** set NEED_UPDATE after comparing versions.
*/
def compareVersion(versionToBeDeployed, localVersionYml) {
	def localVersions = readYaml file: localVersionYml
	def localVersion = localVersions[BUSINESS_REPO_BRANCH]
	if (localVersion == versionToBeDeployed && UPDATE_ON_SAME_VERSION == false) {
		NEED_UPDATE = false
	}
}

stage("set environment variables") {
    parseJobName()
	handleWebhook()

    AGENT_LABEL = ENV_MAP[STAGE]['label']
    echo "Stages next would be executed on agents with label: ${AGENT_LABEL}."
    NODE_LIST = nodesByLabel label: "${AGENT_LABEL}", offline: false
}

NODE_LIST.each {
	node(it) {
		stage("[${it}] print agent info") {
			sh "ifconfig"
			sh "hostname"
		}
		
		stage("[${it}] deploy") {
			// deploy "stable"
			if (!DEBUG) {
				TRACK_AS_TAG = true
				compareVersion(BUSINESS_REPO_BRANCH, "${DEPLOY_TO}/${LOCAL_VERSION_YML}")
				if (NEED_UPDATE) {
					updateBusinessRepo()
					// get versions of dependent repositories
					setDependentRepoTag("${DEPLOY_TO}/requirements.yml")
					// update local version already deployed
					sh "[[ ! -e ${DEPLOY_TO}/${LOCAL_VERSION_YML} ]] || rm ${DEPLOY_TO}/${LOCAL_VERSION_YML}"
					writeYaml file: "${DEPLOY_TO}/${LOCAL_VERSION_YML}", data: ["${BUSINESS_REPO_NAME}": "${BUSINESS_REPO_BRANCH}"]
					
					updatePipelineConf()
					updateNacosJmeterRepo()
					updateJmeterDependencies()
					updateNacosSnapshot()
				}
			}
			
			// deploy "debug"
			if (["all", "cloud-api-test.git"].contains(UPDATE)) {
				updateBusinessRepo()
			}
			if (["all", "pipeline-conf.git"].contains(UPDATE)) {
				updatePipelineConf()
			}
			if (["all", "nacos-jmeter.git", "nacos (group)"].contains(UPDATE)) {
				updateNacosJmeterRepo()
			}
			if (["all", "nacos snapshot", "nacos (group)"].contains(UPDATE)) {
				updateNacosSnapshot()
			}
		}

	}
}

